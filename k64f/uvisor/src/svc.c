/***************************************************************
 * This confidential and  proprietary  software may be used only
 * as authorised  by  a licensing  agreement  from  ARM  Limited
 *
 *             (C) COPYRIGHT 2013-2014 ARM Limited
 *                      ALL RIGHTS RESERVED
 *
 *  The entire notice above must be reproduced on all authorised
 *  copies and copies  may only be made to the  extent permitted
 *  by a licensing agreement from ARM Limited.
 *
 ***************************************************************/
#include <uvisor.h>
#include "svc.h"
#include "vmpu.h"

#define SVC_HDLRS_MAX 0x3FUL
#define SVC_HDLRS_NUM (ARRAY_COUNT(g_svc_vtor_tbl))
#define SVC_HDLRS_IND (SVC_HDLRS_NUM - 1)

SecBoxTh  g_svc_state[SVC_STATE_MAX_DEPTH];
SecBoxSp *g_svc_stack[SVC_STATE_MAX_BOXES];
SecBoxId  g_svc_state_ptr;
SecBoxId  g_box_num; /* FIXME this goes somewhere else */

void svc_context_thunk(void)
{
    /* FIXME the SVC_GW macro will change */
    SVC_GW(-1, svc_context_thunk);
}

void svc_context_switch_in(SecBoxSp *svc_sp,  uint16_t *svc_pc,
                           uint8_t   svc_imm)
{
    SecBoxId  src_id,  dst_id;
    SecBoxSp *src_sp, *dst_sp;
    SecBoxFn           dst_fn;

    /* gather information from secure gateway */
    svc_gw_check_magic(svc_pc);
    dst_id = (SecBoxId) svc_gw_get_dst_id(svc_imm);
    dst_fn = (SecBoxFn) svc_gw_get_dst_fn(svc_pc);

    /* different behavior with svc_imm == 0x80 */
    if(svc_gw_oop_mode(svc_imm))
    {
        /* TODO */
    }

    /* gather information from current state */
    src_sp = svc_state_validate_sf(svc_sp);
    src_id = svc_state_get_dst_id();
    dst_sp = svc_state_get_last_sp(dst_id);

    /* switch exception stack frame */
    dst_sp = svc_state_switch_sf(src_sp, dst_sp,
                                 (SecBoxFn) svc_context_thunk, dst_fn);
    /* switch ACls */
    vmpu_switch(dst_id);

    /* save the current state */
    svc_state_push(src_id, dst_id, src_sp, dst_sp);
}

void svc_context_switch_out(SecBoxSp *svc_sp)
{
    SecBoxId  src_id,  dst_id;
    SecBoxSp *src_sp, *dst_sp;

    /* gather information from current state */
    dst_id = svc_state_get_dst_id();
    src_id = svc_state_get_src_id();
    dst_sp = svc_state_get_dst_sp();
    src_sp = svc_state_get_src_sp();

    /* check consistency between switch in and switch out */
    if(dst_sp != svc_state_validate_sf(svc_sp))
    {
        /* FIXME raise fault */
        while(1);
    };

    /* pop state */
    svc_state_pop(dst_id, dst_sp);

    /* switch stack frames back */
    svc_state_return_sf(src_sp, dst_sp);

    /* switch ACls */
    vmpu_switch(src_id);
}

void svc_interrupt_thunk(void)
{
}

void svc_interrupt_switch_in(void)
{
}

void svc_interrupt_switch_out(void)
{
}

/* FIXME this function is temporary. Writes to an address should be checked
 *       against a box's ACLs */
static void uvisor_bitband(uint32_t *addr, uint32_t val)
{
    *addr = val;
}

/* SVC handlers */
__attribute__((section(".svc_vector"))) const void *g_svc_vtor_tbl[] = {
    uvisor_bitband,             // 0
};

/*******************************************************************************
 *
 * Function name:   __svc_irq
 * Brief:           SVC handlers multiplexer
 *
 * This function is the main SVC IRQ handler. Execution is multiplexed to the
 * proper handler based on the SVC opcode immediate.There are 2 kinds of SVC
 * handler:
 *
 *     1. Regular (unprivileged or privileged)
 * Regular SVC handlers are likely to be mapped to user APIs for unprivileged
 * code. They allow a maximum of 4 32bit arguments and return a single 32bit
 * argument.
 *
 *     2. Secure context (unprivileged) / interrupt (privileged) switch
 * A special SVC handler is given a shortcut to speed up execution. It is used
 * to switch the context between 2 boxes, during normnal execution
 * (unprivileged) or due to an interrupt (privileged). It accepts 4 arguments
 * generated by the asm code below.
 *
 ******************************************************************************/
static void __attribute__((naked)) __svc_irq(void)
{
    asm volatile(
        "ands   r3, lr, #4\n"               // get mode privileged/unprivileged
        "it     eq\n"
        "beq    called_from_priv\n"

    /* the code here serves calls from unprivileged code and is mirrored below
     * for the privileged case; only minor changes exists between the two */
    "called_from_unpriv:\n"
        "mrs    r0, PSP\n"                  // stack pointer
        "ldrt   r1, [r0, #24]\n"            // stacked pc
        "add    r1, r1, #-2\n"              // pc at SVC call
        "ldrbt  r2, [r1]\n"                 // SVC immediate
        "cmp    r2, %[svc_gateway_start]\n" // check SVC shortcut
        /***********************************************************************
         *  ATTENTION
         ***********************************************************************
         * the special handler
         *    sec_context_switch_in
         * is called here with 4 arguments:
         *    r0 - PSP
         *    r1 - pc of SVCall
         *    r2 - immediate value in SVC opcode
         *    r3 - execution mode (1 = unprivileged)
         * these arguments are defined by the asm code you are reading; when
         * changing this code make sure the same format is used or changed
         * accordingly
         **********************************************************************/
        "bhi    svc_context_switch_in\n"    // shortcut    for SVC#imm  > 0x7F
        "beq    svc_context_switch_out\n"   // shortcut    for SVC#imm == 0x7F
        "cmp    r2, %[svc_hdlrs_num]\n"     // check SVC table overflow
        "ite    ls\n"                       // note: this ITE order speeds it up
        "ldrls  r1, =g_svc_vtor_tbl\n"      // fetch handler from table
        "bxhi   lr\n"                       // abort if overflowing SVC table
        "add    r1, r1, r2, LSL #2\n"       // SVC table offset
        "ldr    r1, [r1]\n"                 // SVC handler
        "push   {lr}\n"                     // save lr for later
        "ldr    lr, =svc_thunk_unpriv\n"    // after handler return to thunk
        "push   {r1}\n"                     // save SVC handler to fetch args
        "ldrt   r3, [r0, #12]\n"            // fetch args (unprivileged)
        "ldrt   r2, [r0, #8]\n"             // pass args from stack (unpriv)
        "ldrt   r1, [r0, #4]\n"             // pass args from stack (unpriv)
        "ldrt   r0, [r0, #0]\n"             // pass args from stack (unpriv)
        "pop    {pc}\n"                     // execute handler (return to thunk)

    ".thumb_func\n"                            // needed for correct referencing
    "svc_thunk_unpriv:\n"
        "mrs    r1, PSP\n"                  // unpriv stack may have changed
        "strt   r0, [r1]\n"                 // store result on stacked r0
        "pop    {pc}\n"                     // return from SVCall

    "called_from_priv:\n"
        "mrs    r0, MSP\n"                  // stack pointer
        "ldr    r1, [r0, #24]\n"            // stacked pc
        "add    r1, r1, #-2\n"              // pc at SVC call
        "ldrb   r2, [r1]\n"                 // SVC immediate
        "cmp    r2, %[svc_gateway_start]\n" // check SVC shortcut
        /***********************************************************************
         *  ATTENTION
         ***********************************************************************
         * the special handler
         *    sec_interrupt_switch_in
         * is called here with 4 arguments:
         *    r0 - MSP
         *    r1 - pc of SVCall
         *    r2 - immediate value in SVC opcode
         *    r3 - execution mode (0 = privileged)
         * these arguments are defined by the asm code you are reading; when
         * changing this code make sure the same format is used or changed
         * accordingly
         **********************************************************************/
        "bhi    svc_interrupt_switch_in\n"  // shortcut    for SVC#imm  > 0x7F
        "beq    svc_interrupt_switch_out\n" // shortcut    for SVC#imm == 0x7F
        "cmp    r2, %[svc_hdlrs_num]\n"     // check SVC table overflow
        "ite    ls\n"                       // note: this ITE order speeds it up
        "ldrls  r1, =g_svc_vtor_tbl\n"      // fetch handler from table
        "bxhi   lr\n"                       // abort if overflowing SVC table
        "add    r1, r1, r2, LSL #2\n"       // SVC table offset
        "ldr    r1, [r1]\n"                 // SVC handler
        "push   {lr}\n"                     // save lr for later
        "ldr    lr, =svc_thunk_priv\n"      // after handler return to thunk
        "push   {r1}\n"                     // save SVC handler to fetch args
        "ldm    r0, {r0-r3}\n"              // pass args from stack
        "pop    {pc}\n"                     // execute handler (return to thunk)

    ".thumb_func\n"                            // needed for correct referencing
    "svc_thunk_priv:\n"
        "str    r0, [sp, #4]\n"             // store result on stacked r0
        "pop    {pc}\n"                     // return from SVCall
        :: [svc_hdlrs_num]     "i" (SVC_HDLRS_IND),
           [svc_gateway_start] "i" (SVC_GW_OFFSET)
    );
}

/*******************************************************************************
 *
 * Function name:   svc_init
 * Brief:           SVC initialization
 *
 ******************************************************************************/
void svc_init(void)
{
    /* register SVC handler */
    ISR_SET(SVCall_IRQn, &__svc_irq);

    /* sanity checks */
    assert(SVC_HDLRS_NUM <= SVC_HDLRS_MAX);
}
